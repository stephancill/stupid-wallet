//
//  SafariWebExtensionHandler.swift
//  safari
//
//  Created by Stephan on 2025/08/17.
//

import SafariServices
import os.log

class SafariWebExtensionHandler: NSObject, NSExtensionRequestHandling {
    
    private let logger = Logger(subsystem: "co.za.stephancill.stupid-wallet", category: "SafariExtension")
    private let appGroupId = "group.co.za.stephancill.stupid-wallet" // Must match App Group capability
    
    // Connection state in-memory for demo purposes
    private var isConnected = false
    
    func beginRequest(with context: NSExtensionContext) {
        guard let item = context.inputItems.first as? NSExtensionItem,
              let userInfo = item.userInfo as? [String: Any] else {
            logger.error("Invalid request format")
            completeRequest(context: context, error: "Invalid request format")
            return
        }
        
        logger.info("Received request userInfo keys: \(String(describing: Array(userInfo.keys)))")
        
        // Handle different types of requests (support nested payloads under common keys)
        let payload: [String: Any]
        if let nested = userInfo["message"] as? [String: Any] {
            logger.info("Detected nested payload under key 'message'")
            payload = nested
        } else if let nested = userInfo["payload"] as? [String: Any] {
            logger.info("Detected nested payload under key 'payload'")
            payload = nested
        } else {
            payload = userInfo
        }

        if let method = payload["method"] as? String {
            logger.info("Handling method: \(method)")
            handleEthereumMethod(method: method, params: payload["params"], context: context)
        } else {
            completeRequest(context: context, error: "No action or method specified")
        }
    }

    
    private func handleEthereumMethod(method: String, params: Any?, context: NSExtensionContext) {
        logger.info("Handling Ethereum method: \(method)")
        
        switch method {
        case "eth_requestAccounts":
            handleRequestAccounts(context: context)
            
        case "eth_accounts":
            handleGetAccounts(context: context)
            
        case "eth_chainId":
            completeRequest(context: context, result: "0x1") // Ethereum mainnet
        
        case "debug_checkStore":
            debugCheckStore(context: context)
            
        default:
            completeRequest(context: context, error: "Method \(method) not implemented")
        }
    }
    
    private func handleRequestAccounts(context: NSExtensionContext) {
        // In a real implementation, this would:
        // 1. Check if the user has already authorized this website
        // 2. If not, show a permission dialog in the main app
        // 3. Return the accounts the user has authorized
        
        // For now, we'll simulate user approval
        logger.info("Requesting accounts - simulating user approval")
        
        // TODO: Implement proper user consent flow
        // This should communicate with the main iOS app to:
        // - Show a permission dialog
        // - Get user approval
        // - Return the appropriate accounts
        
        isConnected = true
        if let address = getSavedAddress(), !address.isEmpty {
            logger.info("eth_requestAccounts returning 1 address")
            completeRequest(context: context, result: [address])
        } else {
            logger.info("eth_requestAccounts found no saved address")
            completeRequest(context: context, result: [])
        }
    }
    
    private func handleGetAccounts(context: NSExtensionContext) {
        // Return saved account if present. We are not yet enforcing per-origin authorization here.
        if let address = getSavedAddress(), !address.isEmpty {
            logger.info("eth_accounts returning 1 address")
            completeRequest(context: context, result: [address])
            return
        }
        logger.info("eth_accounts found no saved address")
        completeRequest(context: context, result: [])
    }

    private func getSavedAddress() -> String? {
        let defaults = UserDefaults(suiteName: appGroupId)
        if defaults == nil {
            logger.error("Failed to open UserDefaults for app group: \(self.appGroupId)")
        }
        let address = defaults?.string(forKey: "walletAddress")
        if let address = address, !address.isEmpty {
            logger.info("Loaded address from app group store")
        } else {
            logger.info("No address stored under key 'walletAddress'")
        }
        return address
    }

    private func debugCheckStore(context: NSExtensionContext) {
        let defaults = UserDefaults(suiteName: appGroupId)
        let canOpen = defaults != nil
        let address = defaults?.string(forKey: "walletAddress") ?? ""
        let result: [String: Any] = [
            "canOpenDefaults": canOpen,
            "hasAddress": !(address.isEmpty),
            "addressLength": address.count
        ]
        logger.info("debug_checkStore: canOpen=\(canOpen, privacy: .public), hasAddress=\(!(address.isEmpty), privacy: .public), length=\(address.count, privacy: .public)")
        completeRequest(context: context, result: result)
    }
    
    private func completeRequest(context: NSExtensionContext, result: Any) {
        let response = NSExtensionItem()
        response.userInfo = ["result": result]
        if let array = result as? [Any] {
            logger.info("Completing request with array result count: \(array.count)")
        } else {
            logger.info("Completing request with result type: \(String(describing: type(of: result)))")
        }
        context.completeRequest(returningItems: [response], completionHandler: nil)
    }
    
    private func completeRequest(context: NSExtensionContext, error: String) {
        let response = NSExtensionItem()
        response.userInfo = ["error": error]
        context.completeRequest(returningItems: [response], completionHandler: nil)
        logger.error("Request completed with error: \(error)")
    }
}
